# Новая система генерации хешей для гостей

## Обзор

Мы заменили длинные MD5 хеши на короткие, читаемые хеши, которые содержат имя гостя. Это делает ссылки более понятными и удобными для использования.

## Формат нового хеша

### Структура
```
{первые_буквы_имени}{случайный_хеш}{timestamp}
```

### Примеры
- **Анаит Ервандовна** → `Anai7x2k629`
- **Ерванд Арамаисович** → `Erva9m4p629`
- **Сергей** → `Serg5n8q629`
- **Мария** → `Mari2k7r629`

### Компоненты
1. **Первые буквы имени** (3-4 символа) - извлекаются из имени гостя
2. **Случайный хеш** (4 символа) - буквы и цифры для уникальности
3. **Timestamp** (3 цифры) - последние 3 цифры текущего времени

## Преимущества

### 1. Читаемость
- Хеш содержит имя гостя, что делает его понятным
- Легко определить, кому принадлежит ссылка

### 2. Короткость
- Длина: 10-11 символов вместо 32 символов MD5
- Более удобные ссылки для отправки

### 3. Уникальность
- Комбинация имени + случайного хеша + timestamp гарантирует уникальность
- Нет коллизий между гостями

### 4. Безопасность
- Случайная часть делает хеш непредсказуемым
- Timestamp добавляет дополнительную уникальность

## Реализация

### Backend (Python)
```python
def generate_guest_hash(guest_name, event_id):
    # Очищаем имя от лишних символов
    clean_name = ''.join(c.lower() for c in guest_name if c.isalpha())
    
    # Берем первые 3-4 буквы имени
    name_part = clean_name[:4] if len(clean_name) >= 4 else clean_name
    
    # Генерируем случайный хеш
    chars = string.ascii_lowercase + string.digits
    random_part = ''.join(random.choice(chars) for _ in range(4))
    
    # Добавляем timestamp
    timestamp = str(int(time.time()))[-3:]
    
    return f"{name_part}{random_part}{timestamp}"
```

### Frontend (JavaScript)
```javascript
function generateRandomHash() {
    const nameInput = document.getElementById('name');
    const guestName = nameInput ? nameInput.value.trim() : '';
    
    if (guestName) {
        // Словарь для транслитерации русских букв
        const translitMap = {
            'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ё': 'e',
            'ж': 'zh', 'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm',
            'н': 'n', 'о': 'o', 'п': 'p', 'р': 'r', 'с': 's', 'т': 't', 'у': 'u',
            'ф': 'f', 'х': 'h', 'ц': 'ts', 'ч': 'ch', 'ш': 'sh', 'щ': 'sch',
            'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya',
            'А': 'a', 'Б': 'b', 'В': 'v', 'Г': 'g', 'Д': 'd', 'Е': 'e', 'Ё': 'e',
            'Ж': 'zh', 'З': 'z', 'И': 'i', 'Й': 'y', 'К': 'k', 'Л': 'l', 'М': 'm',
            'Н': 'n', 'О': 'o', 'П': 'p', 'Р': 'r', 'С': 's', 'Т': 't', 'У': 'u',
            'Ф': 'f', 'Х': 'h', 'Ц': 'ts', 'Ч': 'ch', 'Ш': 'sh', 'Щ': 'sch',
            'Ъ': '', 'Ы': 'y', 'Ь': '', 'Э': 'e', 'Ю': 'yu', 'Я': 'ya'
        };
        
        // Очищаем имя от лишних символов и транслитерируем
        let cleanName = '';
        for (let c of guestName) {
            if (c.match(/[a-zA-Zа-яА-Я]/)) {
                // Транслитерируем русские буквы
                if (translitMap[c]) {
                    cleanName += translitMap[c];
                } else {
                    // Оставляем латинские буквы как есть
                    cleanName += c.toLowerCase();
                }
            }
        }
        
        // Берем первые буквы
        const namePart = cleanName.substring(0, 4);
        
        // Генерируем случайную часть
        const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
        let randomPart = '';
        for (let i = 0; i < 4; i++) {
            randomPart += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        
        // Добавляем timestamp
        const timestamp = Date.now().toString().slice(-3);
        
        return `${namePart}${randomPart}${timestamp}`;
    }
    
    // Fallback для случая без имени
    return generateRandomHashFallback();
}
```

## Автоматическое обновление

### При создании приглашения
- Хеш генерируется автоматически при загрузке страницы
- При изменении имени гостя хеш обновляется автоматически
- Кнопка обновления для ручной генерации нового хеша

### При импорте CSV
- Каждый гость получает уникальный хеш на основе своего имени
- Хеши генерируются сервером для обеспечения уникальности

## Примеры ссылок

### Старый формат
```
http://localhost:5000/invite?h=a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6
```

### Новый формат
```
http://localhost:5000/invite?h=Anai7x2k629
http://localhost:5000/invite?h=Erva9m4p629
http://localhost:5000/invite?h=Serg5n8q629
```

## Тестирование

Запустите тест для проверки функции:
```bash
python simple_hash_test.py
```

Тест проверяет:
- Генерацию хешей для разных имен
- Уникальность хешей
- Корректность формата
- Примеры ссылок

## Миграция

### Существующие приглашения
- Старые MD5 хеши продолжают работать
- Новые приглашения используют новый формат
- Можно обновить существующие хеши при необходимости

### Обратная совместимость
- Система поддерживает оба формата хешей
- Функция `getInvitationByHash()` работает с любым форматом

## Безопасность

### Защита от коллизий
- Комбинация имени + случайного хеша + timestamp
- Проверка уникальности в базе данных
- Автоматическая генерация нового хеша при конфликте

### Защита от перебора
- Случайная часть делает хеш непредсказуемым
- Timestamp добавляет временную уникальность
- Длина хеша достаточна для безопасности

## Заключение

Новая система генерации хешей значительно улучшает пользовательский опыт:
- Более короткие и понятные ссылки
- Легкая идентификация гостей
- Сохранение безопасности и уникальности
- Обратная совместимость с существующими приглашениями
